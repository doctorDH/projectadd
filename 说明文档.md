# OpenSpec 实践记录笔记

> 本文记录了在一个 C++ Shell 模拟器项目中从零开始使用 OpenSpec 的完整过程。
> 目标读者：希望通过实际案例掌握 OpenSpec 原理与实践方法的开发者。

---

## 项目背景

一个简单的工程实践迭代案例，这是随手写的一个单文件工程，用于创建一个简易shell将常用的unix指令支持到windows使用，通过和openspec对话探索改进方向并实际迭代来探索openspec的使用，用于学习openspec的使用流程和原理。

```c++
#include <iostream>
#include <string>

using namespace std;

int main() {
	bool is_exit = false;
	while (!is_exit) {
		string input_cmd;
		string exe_cmd;
		cout << ">>";
		cin >> input_cmd;
		if (input_cmd == "ls") {
			exe_cmd = "dir";
			if (cin.rdbuf()->in_avail() > 1) {
				string arg;
				cin >> arg;
				exe_cmd += " " + arg;
			}
			system(exe_cmd.c_str());
		}
		else if (input_cmd == "exit" || input_cmd == "quit") {
			is_exit = true;
			continue;
		}
		else {
			cout << "命令" << input_cmd << "不支持！" << endl;
		}
	}
	return 0;
}
```



## 目录

1. [OpenSpec 是什么](#1-openspec-是什么)
2. [初始化：目录结构与文件说明](#2-初始化目录结构与文件说明)
3. [探索阶段：需求讨论与迭代规划](#3-探索阶段需求讨论与迭代规划)
4. [创建变更：openspec new change](#4-创建变更openspec-new-change)
5. [Artifact 1：proposal.md](#5-artifact-1proposalmd)
6. [Artifact 2：specs/](#6-artifact-2specs)
7. [Artifact 3：design.md](#7-artifact-3designmd)
8. [Artifact 4：tasks.md](#8-artifact-4tasksmd)
9. [实现阶段：/opsx:ff 与代码落地](#9-实现阶段opsx-ff-与代码落地)
10. [归档变更：openspec archive](#10-归档变更openspec-archive)
11. [当前进度与下一步](#11-当前进度与下一步)
12. [关键概念速查](#12-关键概念速查)

---

## 1. OpenSpec 是什么

OpenSpec 是一个**规格驱动开发（Spec-Driven Development）** 工具，核心理念是：

> 在写代码之前，先把"为什么做"、"做什么"、"怎么做"用文档说清楚。

它通过强制的 artifact 依赖关系，引导开发者按顺序完成：

```
proposal（WHY）→ specs（WHAT）→ design（HOW）→ tasks（CHECKLIST）→ 实现代码
```

每一步都是下一步的前提，确保实现始终对齐需求。

### 安装

```bash
npm install -g @fission-ai/openspec
```

### 核心工作流（spec-driven）

OpenSpec 内置唯一工作流 `spec-driven`，其 artifact 序列为：

| Artifact | 文件名 | 回答的问题 | 依赖 |
|---|---|---|---|
| proposal | `proposal.md` | 为什么要做这个变更？ | 无 |
| specs | `specs/**/*.md` | 系统应该做什么？ | proposal |
| design | `design.md` | 技术上怎么实现？ | proposal |
| tasks | `tasks.md` | 具体做哪些事情？ | specs + design |

---

## 2. 初始化：目录结构与文件说明

### 执行命令

```bash
openspec init
```

### 生成的目录结构

```
openspec/
├── config.yaml          ← 项目配置文件（需要手动填写）
├── changes/             ← 所有进行中的变更工作区
│   └── archive/         ← 已完成的变更存档目录
└── specs/               ← 永久规格知识库（archive 后自动更新）
```

### `config.yaml` 详解

初始化后的 `config.yaml` 内容：

```yaml
schema: spec-driven
```

**可配置项说明：**

```yaml
# 必填：工作流模式（目前只有 spec-driven）
schema: spec-driven

# 推荐填写：项目背景，AI 创建 artifact 时会读取此内容
# 越详细，AI 生成的 artifact 越贴合项目实际
context: |
  Tech stack: C++14, MSVC, Windows
  Project type: Command-line shell simulator
  Coding style: Google C++ Style Guide
  Domain: Developer tools / shell utilities

# 可选：为各阶段 artifact 添加自定义规则
rules:
  proposal:
    - Keep proposals under 500 words
    - Always include a "Non-goals" section
  specs:
    - Each requirement must have at least 2 scenarios
    - Use Chinese for requirement descriptions
  design:
    - Always include alternatives considered
  tasks:
    - Break tasks into chunks of max 2 hours
```

### `changes/` 目录的作用

这是**变更工作区**。每次开始一个新功能或重构，就在这里创建一个子目录。
每个变更目录包含该变更全生命周期的所有文档，相互隔离，互不干扰。

### `specs/` 目录的作用

这是**永久规格知识库**，是整个 OpenSpec 系统最重要的输出。

- 初始化后为空，不需要手动创建内容
- 通过 `openspec archive` 命令自动从变更中合并生成
- 始终反映系统当前的**实际行为规格**
- 是项目的"活文档"，随每次变更自动更新

---

## 3. 探索阶段：需求讨论与迭代规划

在创建任何变更之前，值得花时间做**探索（Explore）**——理清问题、规划迭代路径。

### 本项目的背景

原始代码（`main.cpp`，30行）存在以下问题：

```
main.cpp（面向过程）
├── 所有逻辑堆在 main() 的 if-else 链中
├── 命令参数解析不完整（cin >> 只读第一个词）
├── 中文错误信息乱码
└── 扩展性为零（每加一个命令就改核心逻辑）
```

### 规划的迭代路线图

探索阶段输出了一个清晰的两步迭代计划：

```
Change 1: oop-refactor
├── 目标：面向过程 → OOP 多文件架构
├── 解决：扩展性、参数解析、乱码
└── 产出 specs：shell-core, command-system

        ↓ archive 后

Change 2: basic-unix-commands（未来）
├── 目标：添加 8 个常用 Unix 命令
│         pwd, cd, mkdir, rm, cp, mv, cat, echo
└── 产出 specs：unix-commands（大量 ADDED Requirements）
```

**为什么要分两个 Change？**

每个 Change 应该有单一、清晰的关注点：
- Change 1 解决的是**架构问题**（怎么组织代码）
- Change 2 解决的是**功能问题**（支持哪些命令）

混在一起会导致 specs 职责模糊，archive 后的知识库难以维护。

---

## 4. 创建变更：openspec new change

### 执行命令

```bash
openspec new change "oop-refactor"
```

### 生成的文件

```
openspec/changes/oop-refactor/
└── .openspec.yaml          ← 变更元数据文件（自动生成，无需手动编辑）
```

### `.openspec.yaml` 详解

```yaml
schema: spec-driven    # 本变更使用的工作流
created: 2026-02-27    # 创建日期
```

**这个文件的作用：**

- OpenSpec CLI 通过扫描 `.openspec.yaml` 来识别哪些目录是"变更"
- `openspec list` / `openspec status` / `openspec archive` 等命令都依赖它
- **不需要手动编辑**，由 CLI 管理
- 变更 archive 后，连同所有文档一起移入 `changes/archive/`，作为历史记录保留

### 查看变更状态

```bash
openspec status --change "oop-refactor"
```

输出：

```
Change: oop-refactor
Schema: spec-driven
Progress: 0/4 artifacts complete

[ ] proposal
[-] design    (blocked by: proposal)
[-] specs     (blocked by: proposal)
[-] tasks     (blocked by: design, specs)
```

**依赖关系图：**

```
              proposal
             ↙        ↘
          specs       design      ← 并行，都依赖 proposal，彼此不依赖
             ↘        ↙
               tasks
```

`specs` 和 `design` 是**并行**的，可以同时创建，但都必须在 `proposal` 之后。

### 获取下一步指令

```bash
openspec instructions proposal --change "oop-refactor"
```

此命令输出：当前 artifact 的模板、说明、依赖文件路径、以及完成后解锁哪些 artifact。
**每次创建 artifact 前都应该执行此命令**，确保了解该 artifact 的要求。

---

## 5. Artifact 1：proposal.md

### 文件路径

```
openspec/changes/oop-refactor/proposal.md
```

### 文件内容（本项目实际内容）

```markdown
## Why

当前实现将所有逻辑集中在 main() 函数的 if-else 链中，导致每新增一条命令都
需要修改核心逻辑，无法扩展。重构为 OOP 架构以支持后续持续添加 Unix 命令。

## What Changes

- **BREAKING**: main.cpp 从单文件重构为多文件项目结构
- 引入 Shell 类，负责主循环与输入读取
- 引入抽象基类 CommandHandler，定义命令接口
- 引入 CommandRegistry，负责命令注册与分发
- 将 ls、exit 迁移为独立的 Command 类
- 修复命令行参数解析（整行读取替代单词读取）
- 修复中文错误信息乱码问题

## Capabilities

### New Capabilities
- `shell-core`: Shell 主循环行为，包括输入读取、提示符显示、退出控制
- `command-system`: 命令注册、分发与错误处理行为

### Modified Capabilities
（无，这是首次建立规格基线）

## Impact

- 影响文件：main.cpp（拆分重构）
- 新增文件：Shell.h/cpp、Command.h、CommandRegistry.h/cpp、
            commands/LsCommand.h/cpp、commands/ExitCommand.h/cpp
- 无外部依赖变更
```

### 各章节说明

| 章节 | 必填 | 作用 |
|---|---|---|
| `## Why` | ✅ | 说明动机，1-2句话，聚焦"问题"和"时机" |
| `## What Changes` | ✅ | 变更内容列表，BREAKING 变更需标注 |
| `## Capabilities` | ✅ | **最关键**：声明本次变更影响哪些规格能力 |
| `## Impact` | ✅ | 影响范围：文件、API、依赖 |

### `## Capabilities` 为什么最关键？

Capabilities 章节是 **proposal 和 specs 之间的契约**：

```
proposal 中声明：
  New Capabilities:
    - `shell-core`: ...
    - `command-system`: ...

↓ 这决定了下一步必须创建：

specs/shell-core/spec.md    ← 一个 capability 对应一个 spec 文件
specs/command-system/spec.md
```

**如果 proposal 里没有声明 capability，specs 阶段就不知道要写什么。**

### Capability 的命名原则

- 使用 `kebab-case`（如 `shell-core`，不是 `ShellCore` 或 `shell_core`）
- 按**关注点**划分，而非按文件或类划分
- 每个 capability 应该能**独立演化**

```
正确示例：
  shell-core      ← 用户交互层的行为（循环、提示符、退出）
  command-system  ← 命令执行层的行为（注册、分发、报错）

错误示例（按文件划分）：
  shell-class     ← 这是实现，不是关注点
  main-function   ← 这是代码，不是行为
```

### proposal.md 在后续流程中的作用

| 时机 | 作用 |
|---|---|
| 创建 specs 时 | AI 读取 Capabilities 列表，确定要写哪些 spec 文件 |
| 创建 design 时 | AI 读取 Why 和 What Changes，理解变更背景 |
| 创建 tasks 时 | AI 读取 Impact，了解影响范围 |
| archive 后 | 保存在 `changes/archive/oop-refactor/proposal.md`，作为历史记录 |
| 未来 Change 2 时 | 不直接引用，但 `openspec/specs/` 中积累的规格库来自它 |

---

## 6. Artifact 2：specs/

### 文件路径

```
openspec/changes/oop-refactor/specs/
├── shell-core/
│   └── spec.md
└── command-system/
    └── spec.md
```

> ⚠️ 注意：这里的 `specs/` 是**变更内的 delta 规格**，
> 不是 `openspec/specs/`（永久知识库）。两者不同！

### 理解 Delta 规格

变更内的 spec 文件不是直接写"系统现在有什么需求"，
而是写"**本次变更对规格库做了哪些改变**"——即 Delta（增量）。

```
Delta 操作类型（用 ## 头部标识）：

## ADDED Requirements      ← 新增需求（首次建立时全部是 ADDED）
## MODIFIED Requirements   ← 修改已有需求（需复制原始内容再修改）
## REMOVED Requirements    ← 删除已有需求（需说明原因和迁移方案）
## RENAMED Requirements    ← 重命名需求（FROM:/TO: 格式）
```

### spec 文件的结构

每个 spec 文件由一组 **Requirement（需求）** 组成，每个 Requirement 包含若干 **Scenario（场景）**：

```markdown
## ADDED Requirements

### Requirement: <需求名称>
<需求的规范性描述，使用 SHALL/MUST 表达强制性>

#### Scenario: <场景名称>
- **WHEN** <触发条件>
- **THEN** <期望结果>
```

**格式要求（非常严格）：**

| 元素 | 格式 | 注意事项 |
|---|---|---|
| Requirement 标题 | `### Requirement: 名称`（3个#） | 名称在 archive 时用于匹配 |
| Scenario 标题 | `#### Scenario: 名称`（**4个#**） | **必须是4个#，用3个#会导致解析失败** |
| 规范性语言 | SHALL / MUST | 避免 should / may（非强制性） |
| 场景数量 | 每个 Requirement 至少1个 Scenario | 无 Scenario 的 Requirement 不完整 |

### 本项目的两个 spec 文件

**`shell-core/spec.md`** — 描述 Shell 主循环的用户可见行为：

```markdown
## ADDED Requirements

### Requirement: 持续命令循环
Shell 程序 SHALL 在启动后进入持续循环，每轮显示提示符并等待用户输入，
直到用户主动退出。

#### Scenario: 正常启动循环
- **WHEN** 程序启动
- **THEN** 显示 ">>" 提示符并等待输入

#### Scenario: 命令执行后继续循环
- **WHEN** 用户输入并执行一条命令
- **THEN** 命令执行完毕后再次显示 ">>" 提示符

### Requirement: 整行输入读取
Shell 程序 SHALL 将用户的一行输入（包含命令名和所有参数）作为整体读取。

#### Scenario: 带参数的命令输入
- **WHEN** 用户输入 "ls -la /path"
- **THEN** 系统将完整字符串传递给命令解析器，不丢失任何参数

#### Scenario: 空行输入
- **WHEN** 用户直接按下回车，输入为空行
- **THEN** 系统忽略该输入，重新显示 ">>" 提示符

### Requirement: 退出控制
Shell 程序 SHALL 在用户输入 "exit" 或 "quit" 时正常终止程序。

#### Scenario: 输入 exit
- **WHEN** 用户输入 "exit"
- **THEN** 程序正常终止，退出码为 0

#### Scenario: 输入 quit
- **WHEN** 用户输入 "quit"
- **THEN** 程序正常终止，退出码为 0
```

**`command-system/spec.md`** — 描述命令注册与执行系统的行为：

```markdown
## ADDED Requirements

### Requirement: 命令注册
系统 SHALL 提供命令注册机制，允许将命令名称与其处理器绑定。

#### Scenario: 注册新命令
- **WHEN** 以命令名称和处理器对象注册一条命令
- **THEN** 该命令名称可被后续执行调用识别

### Requirement: 命令分发执行
系统 SHALL 根据用户输入的命令名称查找对应处理器并执行，同时传递参数列表。

#### Scenario: 执行已注册命令（无参数）
- **WHEN** 用户输入已注册的命令名，无附加参数
- **THEN** 对应的处理器被调用，参数列表为空

#### Scenario: 执行已注册命令（带参数）
- **WHEN** 用户输入已注册的命令名及若干参数（如 "ls -la /path"）
- **THEN** 对应的处理器被调用，参数列表包含 ["-la", "/path"]

### Requirement: 未知命令错误提示
系统 SHALL 在用户输入未注册的命令时，输出明确的错误提示，且程序不崩溃。

#### Scenario: 输入未知命令
- **WHEN** 用户输入一个未注册的命令名称
- **THEN** 系统输出 "不支持的命令: <命令名>"，继续等待下一条输入

### Requirement: 命令参数解析
系统 SHALL 将用户输入的整行字符串解析为命令名和参数列表，以空格为分隔符。

#### Scenario: 解析命令名和参数
- **WHEN** 用户输入 "cp source.txt dest.txt"
- **THEN** 命令名为 "cp"，参数列表为 ["source.txt", "dest.txt"]
```

### 为什么拆成两个 capability 而不是一个？

**原则：capability 按独立的演化轴划分，不按文件或类划分。**

```
shell-core 的未来演化路径：    command-system 的未来演化路径：
  命令历史（↑↓键）               命令别名（alias）
  彩色提示符                     管道支持（|）
  多行输入                       命令补全

两者演化方向完全独立 → 应该是两个 capability
```

**验证方法**：问自己"Change 2（添加 unix 命令）会修改哪个 spec？"

```
shell-core/spec.md    → 不需要改（循环和退出行为没变）
command-system/spec.md → 不需要改（注册和分发机制没变）
unix-commands/spec.md  → 新建（这才是 Change 2 的关注点）
```

每次变更只影响它真正关心的 capability，规格库保持清晰。

### spec 文件在后续流程中的作用

**在本次 Change 1 内：**

| 时机 | 作用 |
|---|---|
| 创建 tasks 时 | AI 读取 spec，确保任务清单覆盖所有 Requirement |
| 实现代码时 | 每个 Scenario 是一个"验收标准"，实现完成后可对照验证 |

**执行 `openspec archive` 后：**

```
Delta（临时，在 changes/ 内）          →  Main（永久，在 openspec/specs/ 内）

changes/oop-refactor/specs/              openspec/specs/
  shell-core/spec.md                       shell-core/spec.md
  （## ADDED Requirements 头部）    →      （ADDED 头部去掉，需求直接保留）
  command-system/spec.md                   command-system/spec.md
```

**Archive 后的 `openspec/specs/shell-core/spec.md` 格式（纯净版）：**

```markdown
### Requirement: 持续命令循环
Shell 程序 SHALL 在启动后进入持续循环...

#### Scenario: 正常启动循环
- **WHEN** 程序启动
- **THEN** 显示 ">>" 提示符并等待输入

（无 ## ADDED 头部，这是系统"当前事实状态"的纯净记录）
```

**在 Change 2 中：**

```
Change 2 的 specs/shell-core/spec.md 需要 MODIFIED 某个需求时：

1. 打开 openspec/specs/shell-core/spec.md（archive 后的纯净版）
2. 找到要修改的 Requirement，复制整个块
3. 粘贴到 Change 2 的 delta spec 的 ## MODIFIED Requirements 下
4. 修改需要变更的部分
5. archive 时，系统用新内容替换旧内容

⚠️ 陷阱：MODIFIED 时必须复制完整的 Requirement 块，
          不能只写变化的部分，否则 archive 时会丢失原有内容
```

### specs/ 的长期价值

```
随着 Change 积累，openspec/specs/ 成为：

┌────────────────────────────────────────────────────┐
│              项目的"活文档"知识库                    │
│                                                    │
│  • 始终反映系统当前的实际行为                        │
│  • 每个 Scenario 是一个可执行的验收测试描述           │
│  • 新人入职，读 specs/ 即可了解系统做什么             │
│  • 重构时，specs/ 是"行为不变"的约束基准              │
│  • 不需要手动维护，archive 自动更新                   │
└────────────────────────────────────────────────────┘
```

---

## 7. Artifact 3：design.md

### 文件路径

```
openspec/changes/oop-refactor/design.md
```

### design.md 的定位

design.md 回答 **HOW**——技术上怎么实现。它是三个 artifact 中**最可选**的一个：
OpenSpec 的 schema 说明，只在以下情况才需要创建：

```
需要创建 design.md 的情形：
  ✅ 跨多个模块/文件的架构性变更（本次重构满足）
  ✅ 引入新的外部依赖或数据模型变化
  ✅ 有安全、性能或迁移复杂性
  ✅ 有技术方案不明确、需要在编码前决策的内容

可以省略 design.md 的情形：
  ⚪ 简单的 bug 修复，方案显而易见
  ⚪ 纯文档或配置变更
  ⚪ 在已有架构内添加小功能（Change 2 添加命令可考虑省略）
```

### 文件内容（本项目实际内容）

```markdown
## Context

当前 main.cpp 为 30 行的面向过程实现，所有命令逻辑通过 if-else 链处理，
参数解析使用 cin >> 导致多参数丢失，中文错误信息因编码问题乱码。
本次重构为多文件 OOP 架构，为后续 Change 2（basic-unix-commands）持续添加命令提供扩展基础。

平台约束：仅 Windows，使用 MSVC 编译器，C++14 标准。

## Goals / Non-Goals

**Goals:**
- 建立可扩展的命令注册/分发架构（新增命令无需修改核心逻辑）
- 修复整行参数解析（getline 替代 cin >>）
- 修复中文错误信息输出乱码
- 保持 ls 和 exit 原有功能行为不变

**Non-Goals:**
- 添加新的 Unix 命令（属于 Change 2）
- 实现管道、重定向等高级 Shell 特性
- 跨平台支持（仅针对 Windows）
- 单元测试框架接入（当前阶段不引入）

## Decisions

### 决策 1：命令处理器使用抽象基类而非 std::function
**选择：** 抽象基类 CommandHandler
**备选：** std::function<void(vector<string>)>
**理由：** 抽象基类允许每个命令封装自身状态；OOP 教学目的更直观

### 决策 2：CommandRegistry 使用裸指针 map
**选择：** map<string, CommandHandler*>，Registry 拥有所有权，析构时 delete
**备选：** map<string, unique_ptr<CommandHandler>>
**理由：** 裸指针对初学者更易理解内存管理；后续可无破坏性升级

### 决策 3：多文件项目结构
Shell.h/cpp、Command.h、CommandRegistry.h/cpp、commands/LsCommand.h/cpp ...
**理由：** commands/ 形成扩展槽，Change 2 只需新增文件，核心代码零修改

### 决策 4：编码修复使用 SetConsoleOutputCP(65001)
**备选：** wcout 宽字符输出
**理由：** 一行代码，无需修改所有输出语句

### 决策 5：Shell 整行读取使用 getline
**备选：** cin >> 逐词读取
**理由：** 保留完整行内容，支持带空格的路径参数

## Risks / Trade-offs

- [裸指针内存管理] → 析构函数中遍历 map delete
- [system() 命令注入] → 学习项目暂不处理，记录为已知安全限制
- [引号和空格路径] → 当前 spec 未要求，记录为已知限制

## Migration Plan

1. 新建各头文件和实现文件（不删除 main.cpp）
2. 逐类实现，每个类独立可编译验证
3. 最后修改 main.cpp，接入新架构
4. 编译运行，验证 ls、exit、quit 功能与重构前一致
5. 验证未知命令输出正确的中文错误信息（无乱码）
```

### 各章节说明

| 章节 | 必填 | 作用 |
|---|---|---|
| `## Context` | ✅ | 背景说明：当前状态、约束、来龙去脉 |
| `## Goals / Non-Goals` | ✅ | **Non-Goals 同样重要**：明确不做什么，防止范围蔓延 |
| `## Decisions` | ✅ | **核心章节**：每个关键决策 = 选什么 + 备选 + 理由 |
| `## Risks / Trade-offs` | ✅ | 已知风险和应对方案，格式：[风险] → 缓解措施 |
| `## Migration Plan` | ⚪ | 有迁移复杂性时填写，简单变更可省略 |
| `## Open Questions` | ⚪ | 编码前未决策的问题，开始实现前需解决 |

### Decisions 章节的写法要点

这是 design.md 最有价值的部分。**好的决策记录 = 选什么 + 没选什么 + 为什么**：

```
❌ 差的写法（只说结论）：
   "使用抽象基类实现命令处理"

✅ 好的写法（说明选择与理由）：
   **选择：** 抽象基类 CommandHandler
   **备选：** std::function<void(vector<string>)>
   **理由：** 抽象基类允许命令封装状态；OOP 教学目的更直观
```

6个月后的你，或新加入的同事，看到"备选方案"和"理由"，就不会重蹈覆辙、
反复讨论同一个已经决策过的问题。

### design.md 在后续流程中的作用

| 时机 | 作用 |
|---|---|
| 创建 tasks 时 | AI 读取 Decisions，按架构决策拆分实现任务 |
| 实现代码时 | 开发者参照 design 写代码，不需要临时决策 |
| archive 后 | 保存在 `changes/archive/oop-refactor/design.md`，作为历史记录 |
| Change 2 时 | 若架构需要扩展，读取此 design 了解现有约束和已有决策 |
| 代码 review 时 | 审查者可对照 design 验证实现是否与决策一致 |

### design.md 与 specs 的分工

```
specs（WHAT）                    design（HOW）
─────────────────────────────    ──────────────────────────────
"用户输入未知命令时，系统           "CommandRegistry.execute() 在
 SHALL 输出错误提示"               map 中找不到 key 时，输出
                                  '不支持的命令: <name>'"
↑ 行为约束，不涉及实现              ↑ 技术方案，引用了具体类和方法

specs 可以有多种 design 实现       design 必须满足所有 specs
```

---

## 8. Artifact 4：tasks.md

### 文件路径

```
openspec/changes/oop-refactor/tasks.md
```

### tasks.md 的定位

tasks.md 回答 **CHECKLIST**——具体要做哪些事。它是 specs + design 的**产物**，也是 AI 进入"apply（实现）"阶段的唯一入口：

```
specs（WHAT 规格）  +  design（HOW 架构）
           ↓
        tasks.md
           ↓
   /opsx:ff 实现代码（逐条打勾）
```

**为什么需要 tasks.md 而不是直接写代码？**

```
直接写代码的问题：
  - AI 可能遗漏某个 Scenario 对应的实现
  - 无法追踪"做到哪里了"
  - 实现顺序混乱，中途出错难以定位

tasks.md 的价值：
  ✅ 把 specs 的每个 Requirement 翻译成可执行的编码步骤
  ✅ 把 design 的每个决策落地为具体的类/方法/文件
  ✅ 用 - [ ] 复选框追踪进度，apply 时逐条打勾
  ✅ 实现完成后，tasks.md 的完成状态即"变更完成的证明"
```

### 文件内容（本项目实际内容）

```markdown
# Tasks: oop-refactor

## Prerequisites

- [x] proposal.md — 变更目标已确认
- [x] specs/shell-core/spec.md — Shell 循环、输入读取、退出控制规格已确认
- [x] specs/command-system/spec.md — 命令注册、分发、错误提示、参数解析规格已确认
- [x] design.md — 架构决策已确认

---

## Task Group 1: 项目文件结构搭建
> 对应 design 决策 3：多文件项目结构

- [ ] 1.1 创建 `Command.h`
  - 定义抽象基类 `CommandHandler`，包含纯虚函数 `execute(...)`
  - 定义虚析构函数，防止切片问题

- [ ] 1.2 创建 `CommandRegistry.h` 和 `CommandRegistry.cpp`
  - 成员：`std::map<std::string, CommandHandler*> commands_`
  - 方法：`registerCommand(name, handler)`
  - 方法：`execute(line)` — 解析输入行，查找并执行命令
  - 析构函数：遍历 map，delete 每个 handler

- [ ] 1.3 创建 `Shell.h` 和 `Shell.cpp`
  - 成员：`CommandRegistry registry_`
  - 方法：`run()` — 主循环
  - 构造函数：SetConsoleOutputCP(65001) + 注册所有命令

## Task Group 2: 命令实现
> 对应 proposal"将 ls、exit 迁移为独立 Command 类"

- [ ] 2.1 创建 `commands/` 子目录
- [ ] 2.2 创建 `commands/LsCommand.h/cpp`
- [ ] 2.3 创建 `commands/ExitCommand.h/cpp`

## Task Group 3: 核心行为实现
> 对应 specs 中所有 Requirement 的 Scenario 验收标准

- [ ] 3.1 实现 `CommandRegistry::execute()` — 输入行解析
  - 对应 spec：**命令参数解析 / Scenario: 解析命令名和参数**
- [ ] 3.2 实现 `CommandRegistry::execute()` — 命令分发与错误提示
  - 对应 spec：**命令分发执行** + **未知命令错误提示**
- [ ] 3.3 实现 `Shell::run()` — 主循环与 getline 读取
  - 对应 spec：**持续命令循环** + **整行输入读取**
- [ ] 3.4 实现 `Shell::run()` — 空行处理
  - 对应 spec：**整行输入读取 / Scenario: 空行输入**
- [ ] 3.5 实现退出控制（exit / quit）
  - 对应 spec：**退出控制**

## Task Group 4: 编码与入口改造

- [ ] 4.1 Shell 构造函数中调用 `SetConsoleOutputCP(65001)`
- [ ] 4.2 改造 `main.cpp`（清空原逻辑，接入 Shell 对象）

## Task Group 5: 验证

- [ ] 5.1 验证 `ls`（无参数）
- [ ] 5.2 验证 `ls -la`（带参数）
- [ ] 5.3 验证空行输入
- [ ] 5.4 验证未知命令输出（无乱码）
- [ ] 5.5 验证 `exit` / 5.6 验证 `quit`
```

### 各章节说明

| 章节 | 必填 | 作用 |
|---|---|---|
| `## Prerequisites` | ✅ | 列出前置 artifact，标记 [x] 确认已就绪 |
| `## Task Group N: 标题` | ✅ | 按关注点分组，标注"对应 design/specs 哪条" |
| `- [ ] N.M 任务描述` | ✅ | **必须使用此格式**，apply 阶段用于进度追踪 |
| 任务内缩进说明 | ⚪ | 对 AI 的实现提示，非强制，但建议添加 |
| `## 文件变更清单` | ⚪ | 列出新增/修改的文件，便于 review |

### tasks.md 的关键格式规则

**任务编号格式必须严格遵守：**

```
- [ ] 1.1 任务描述     ← 正确：数字.数字 空格 描述
- [ ] 任务描述         ← 错误：缺少编号，apply 时无法追踪
- [x] 1.1 任务描述     ← 已完成状态：apply 阶段由 AI 打勾
```

**Task Group 与 specs/design 的映射是关键：**

```
specs Requirement  →  Task Group 中有对应任务
design Decision    →  Task Group 中有对应实现步骤
所有 Scenario      →  Task Group 5（验证）中覆盖

如果某个 Requirement 在 tasks 中没有对应任务，
实现阶段可能遗漏，验证时才发现 bug。
```

**Task Group 的分组策略：**

```
推荐按"实现依赖顺序"分组，而非按文件分组：

正确（依赖顺序）：          错误（按文件）：
  Group 1: 接口/基类          Group 1: .h 文件
  Group 2: 具体实现           Group 2: .cpp 文件
  Group 3: 核心逻辑           Group 3: main.cpp
  Group 4: 集成入口
  Group 5: 验证

按依赖顺序分组，AI 在 apply 时不会因为依赖未就绪而报错。
```

### tasks.md 在后续流程中的作用

**在 apply（实现）阶段：**

```bash
/opsx:ff    # 触发 AI 进入实现模式
```

AI 读取 `tasks.md`，按 Group 顺序逐条执行：

```
[x] 1.1 创建 Command.h       ← 写完文件后打勾
[x] 1.2 创建 CommandRegistry ← 写完后打勾
[x] 1.3 创建 Shell           ← 写完后打勾
[x] 2.1 创建 commands/       ← 目录创建后打勾
...
```

每个任务完成时，AI 更新 `tasks.md` 的复选框状态。
任何时候中断，再次执行 `/opsx:ff` 时，AI 从第一个 `[ ]` 未完成任务继续。

**在 archive 后：**

```
tasks.md 连同所有文档一起移入 changes/archive/oop-refactor/
作为历史记录保留，不会合并进 openspec/specs/（specs 只有 spec.md 合并）
```

**在 Change 2 创建时：**

```
Change 2 的 tasks.md 不引用 Change 1 的 tasks，
但 Change 2 的 Task Group 编写时应参考 design.md 中"Migration Plan"
（以及 Change 1 archive 后的 openspec/specs/ 知识库）
```

### 完整 artifact 链路回顾

```
proposal.md
  └─→ 定义了 2 个 Capability：shell-core, command-system

specs/shell-core/spec.md
  └─→ 3 个 Requirement，6 个 Scenario
specs/command-system/spec.md
  └─→ 4 个 Requirement，6 个 Scenario

design.md
  └─→ 5 个架构决策（类结构、内存管理、文件布局、编码、输入方式）

tasks.md（当前步骤）
  └─→ 5 个 Task Group，17 个子任务
  └─→ 每条任务明确对应 specs Requirement 或 design Decision
  └─→ Group 5 验证清单覆盖所有 12 个 Scenario

↓ /opsx:ff

实现代码（9个文件 + 1个改造）
```

---

## 9. 实现阶段：/opsx:ff 与代码落地

### 触发实现

```bash
/opsx:ff    # ff = fast-forward，进入实现模式
```

AI 读取 `tasks.md`，从第一个未完成的 `- [ ]` 开始，逐条执行、逐条打勾。

### .vcxproj 注意事项（VS 项目特有）

**重要陷阱**：新创建的 `.cpp` / `.h` 文件，必须手动加入 VS 项目文件（`.vcxproj`），否则 IDE 构建时会报 `LNK2019` 链接错误。

```
症状：
  error LNK2019: 无法解析的外部符号 Shell::Shell()
  error LNK2019: 无法解析的外部符号 Shell::run()
  → IDE 只编译了 .vcxproj 中列出的文件，新文件不在列表里

修复：在 .vcxproj 的 <ItemGroup> 中补充新文件

  <ItemGroup>
    <ClCompile Include="Shell.cpp" />
    <ClCompile Include="CommandRegistry.cpp" />
    <ClCompile Include="commands\LsCommand.cpp" />
    <ClCompile Include="commands\ExitCommand.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Command.h" />
    <ClInclude Include="Shell.h" />
    <ClInclude Include="CommandRegistry.h" />
    <ClInclude Include="commands\LsCommand.h" />
    <ClInclude Include="commands\ExitCommand.h" />
  </ItemGroup>

修改后，VS 提示"项目文件已在外部修改" → 点击"重新加载"。
```

### 验证场景与 tasks 的对应

Task Group 5（验证）中每条任务直接对应 specs 中的 Scenario：

```
tasks.md 验证任务             对应 spec Scenario
─────────────────────────    ────────────────────────────────
5.1 验证 ls（无参数）    →   命令分发执行 / 执行已注册命令（无参数）
5.2 验证 ls -la         →   命令分发执行 / 执行已注册命令（带参数）
5.3 验证空行输入         →   整行输入读取 / 空行输入
5.4 验证未知命令输出     →   未知命令错误提示 / 输入未知命令
5.5/5.6 验证 exit/quit  →   退出控制 / 输入 exit + 输入 quit
```

所有 Scenario 都有对应验证任务 = 实现完整。

---

## 10. 归档变更：openspec archive

### 触发命令

```bash
/opsx:archive <change-name>
```

### archive 做了什么

archive 是一个**两步操作**，职责完全不同：

```
Step 1：Sync（同步）
  delta specs 内容  →  复制到 openspec/specs/（写入永久知识库）

Step 2：Move（移动）
  openspec/changes/<name>/  →  openspec/changes/archive/YYYY-MM-DD-<name>/
```

**两步的职责区分：**

| 操作 | 目的 | 操作对象 |
|---|---|---|
| **Sync** | 把变更规格"升级"为项目正式规格 | delta spec 的**内容**写入主 specs |
| **Archive** | 把变更过程文档从活跃区移走 | 整个 change **目录**移入 archive |

### archive 前的自动检查流程

```
1. artifact 完成状态检查
   openspec status --change "<name>" --json
   → 有未完成 artifact 时警告，询问是否继续

2. tasks 完成状态检查
   扫描 tasks.md 中 - [ ] 数量
   → 有未打勾任务时警告，询问是否继续

3. delta spec 同步评估
   比对 changes/<name>/specs/ 与 openspec/specs/
   → 显示将新增/修改/删除哪些 Requirement 的摘要
   → 询问：立即同步后归档（推荐）/ 跳过同步直接归档

4. 执行归档
   mkdir openspec/changes/archive（如不存在）
   mv changes/<name> → changes/archive/YYYY-MM-DD-<name>
```

### 归档前后的目录变化

**归档前：**
```
openspec/
├── changes/
│   └── oop-refactor/           ← 活跃工作区
│       ├── .openspec.yaml
│       ├── proposal.md
│       ├── design.md
│       ├── tasks.md
│       └── specs/
│           ├── shell-core/spec.md
│           └── command-system/spec.md
└── specs/                      ← 空
```

**归档后：**
```
openspec/
├── changes/
│   └── archive/
│       └── 2026-02-27-oop-refactor/   ← 完整历史存档
│           ├── .openspec.yaml
│           ├── proposal.md
│           ├── design.md
│           ├── tasks.md
│           └── specs/                  ← 历史快照（冗余但保留）
└── specs/                              ← 永久知识库（已同步）
    ├── shell-core/spec.md              ← 新增
    └── command-system/spec.md          ← 新增
```

### archive 目录里的 specs 是"冗余"的吗？

是的，内容已同步到主 specs，从数据角度确实冗余。
但它是**历史快照**，类比 Git commit 历史：

```
openspec/specs/              =  当前 HEAD（系统现在的规格状态）
archive/xxx/specs/           =  某次 commit（某次变更时的规格快照）
```

### 主 specs（同步后）的格式

delta spec 有操作头 `## ADDED Requirements`，同步到主 specs 后去掉头部：

```markdown
# Spec: shell-core                       ← 纯净版，无操作头部

### Requirement: 持续命令循环
Shell 程序 SHALL 在启动后进入持续循环...

#### Scenario: 正常启动循环
- **WHEN** 程序启动
- **THEN** 显示 ">>" 提示符并等待输入
```

### 对下一个 Change 的意义

```
Change 2（basic-unix-commands）开始时：

① MODIFIED 操作可以引用主 specs 已有内容
   从 openspec/specs/shell-core/spec.md 复制 Requirement 块
   → 粘贴到 Change 2 的 ## MODIFIED Requirements 下修改

② 不重复描述已有规格
   "退出控制"和"命令分发"已在主 specs，无需在 Change 2 中重新写

③ archive 时可以检测冲突
   Change 2 的 MODIFIED 如引用不存在的 Requirement，
   系统能通过主 specs 记录检测到
```

---

## 11. 当前进度与下一步

### 当前状态（Change 1：oop-refactor）

```bash
openspec status --change "oop-refactor"
```

```
Progress: 4/4 artifacts complete ✅

[x] proposal   ✅ openspec/changes/oop-refactor/proposal.md
[x] specs      ✅ openspec/changes/oop-refactor/specs/shell-core/spec.md
                  openspec/changes/oop-refactor/specs/command-system/spec.md
[x] design     ✅ openspec/changes/oop-refactor/design.md
[x] tasks      ✅ openspec/changes/oop-refactor/tasks.md
```

### 当前目录结构

```
openspec/
├── config.yaml
├── changes/
│   ├── archive/
│   └── oop-refactor/
│       ├── .openspec.yaml              ← 变更元数据
│       ├── proposal.md                 ← ✅ 完成
│       ├── design.md                   ← ✅ 完成
│       ├── tasks.md                    ← ✅ 完成
│       └── specs/
│           ├── shell-core/
│           │   └── spec.md             ← ✅ 完成
│           └── command-system/
│               └── spec.md             ← ✅ 完成
└── specs/                              ← 目前为空（等待 archive）
```

---

## 12. 关键概念速查

### Delta 操作符对照表

| 操作符 | 用途 | 格式要求 |
|---|---|---|
| `## ADDED Requirements` | 新增需求 | 直接写新 Requirement |
| `## MODIFIED Requirements` | 修改已有需求 | **必须复制完整原始块**，再修改 |
| `## REMOVED Requirements` | 删除已有需求 | 需包含 **Reason** 和 **Migration** |
| `## RENAMED Requirements` | 仅改名 | `FROM: 旧名` / `TO: 新名` 格式 |

### 常用 CLI 命令速查

```bash
openspec init                              # 初始化项目
openspec new change "<name>"               # 创建新变更
openspec list                              # 列出所有活跃变更
openspec list --specs                      # 列出所有规格
openspec status --change "<name>"          # 查看变更 artifact 进度
openspec instructions <artifact> --change "<name>"  # 获取创建指令
openspec validate --change "<name>"        # 校验 artifact 格式
openspec archive "<name>"                  # 归档完成的变更
openspec schemas                           # 查看可用工作流
```

### specs 的两种形态对比

```
形态一：Delta 规格（变更工作期间）
位置：openspec/changes/<name>/specs/<capability>/spec.md
内容：ADDED/MODIFIED/REMOVED 操作指令
作用：描述"本次变更对规格库的改动"
生命周期：变更完成 archive 后移入 archive/

形态二：Main 规格（永久知识库）
位置：openspec/specs/<capability>/spec.md
内容：纯净的 Requirement + Scenario（无操作头部）
作用：描述"系统当前的实际行为规格"
生命周期：持续存在，每次 archive 自动更新
```

### 一次完整 Change 的生命周期

```
1. openspec new change "<name>"
   └── 创建 changes/<name>/ 和 .openspec.yaml

2. 创建 proposal.md
   └── 声明 Why、What、Capabilities、Impact

3. 创建 specs/（与 design 并行）
   └── 每个 Capability 一个 delta spec 文件

4. 创建 design.md（与 specs 并行）
   └── 架构决策、技术选型、风险分析

5. 创建 tasks.md
   └── 依赖 specs + design，具体实现任务清单

6. 实现代码（/opsx:ff）
   └── 逐条完成 tasks.md 中的任务

7. openspec archive "<name>"
   └── delta specs → openspec/specs/（永久更新）
   └── changes/<name>/ → changes/archive/<name>/
```

---

*笔记记录时间：2026-02-27*
*项目：C++ Unix Shell 模拟器（Windows 平台）*
*当前进度：Change 1 (oop-refactor) — 全流程完成，已归档至 changes/archive/2026-02-27-oop-refactor/*
